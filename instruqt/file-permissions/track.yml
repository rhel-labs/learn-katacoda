slug: using-file-permissions
id: 7sxmpp4hpeoz
type: track
title: '[Admin101] Using file permissions'
teaser: Control access to file content using the Linux file permission system.
description: |-
  # Overview:
  It is common for multiple users to potentially have access to the same files. This means that understanding file permissions is a foundational skill for any system administrator. This lab is designed to provide you with a basic understanding of how to control who has access to various files on a system.

  # Goal:
  After completing this scenario, users will be able to read, understand, and change permissions of files and directories on their system.

  # Concepts included in this scenario:
  * Learn how to view permissions with `ls -l`
  * Explore how changing user accounts impacts interacting with files
  * Use `chmod` to change file permissions
  * Test out `chown` with example user accounts and groups
  * Learn how to use `find` to filter files based on their permissions
icon: https://storage.googleapis.com/instruqt-frontend/img/tracks/redhat.png
level: beginner
tags:
- admin101
owner: rhel
developers:
- ehendric@redhat.com
private: false
published: true
skipping_enabled: true
challenges:
- slug: 01-what-are-file-permissions
  id: kg8izoev0o1f
  type: challenge
  title: What are file permissions?
  teaser: Understanding the read, write, and execute categories
  notes:
  - type: text
    contents: |-
      What are file permissions?
      File permissions determine which users can operate on files on a system. These operations are broken down into three categories:

      * Read: Viewing the contents of a file
      * Write: Changing the contents of a file
      * Execute: Running contents of a file as code

      Permissions function differently when applied to directories. Read allows users to view the contents of a directory, write allows users to add and delete files, and execute allows users to `cd` into that directory.

      >_NOTE:_ There are three more permissions on top of the ones explained above: setuid, setgid, and sticky bit. These are much less commonly used and therefore outside of the scope of this lab, but this article on [Understanding Linux File Permissions](https://www.linux.com/training-tutorials/understanding-linux-file-permissions/) is a great place to start if you want more information on these additional permissions.
  assignment: |-
    It is important to properly assign permissions to files and directories created on a shared system so that files are not accidentally (or maliciously) tampered with, destroyed, or executed. The next section shows you how to view the permissions of files in an example directory.

    # Displaying files and their permissions

    For this lab, several files have been created for you to work with in the /srv directory. Use the `cd` command to navigate there:

    ```
    cd /srv
    ```

    The command `ls -l` can be used to look at the permissions associated with each file in the directory. The output for this can be cryptic at first, so this step will walk you through what each character means. Take a look at the contents of the current directory. Use the long listing option (`-l`) to display information about permissions for each item.

    ```
    ls -l
    ```

    <pre class=file>
    drw-r-----. 2 root root  94 Jun  2 21:08 proprietary
    -rwxr-x---. 1 root root  66 Jun  2 21:08 status.sh
    -rwxr-x---. 1 root root 117 Jun  2 21:08 tasks.txt
    </pre>

    The first column of the output above is a string conveying the access mode. The access mode __-rwxr-x---__, seen here for the __status.sh__ file, conveys the following information:

    ![permission string breakdown](https://github.com/rhel-labs/learn-katacoda/raw/master/instruqt/file-permissions/assets/lsExplanation.png)

    The middle columns of the `ls` output give information about the user ownership and group ownership of the files, their size, the time last modified, and finally the file/directory name itself. The next steps will walk you through the importance of the file ownership fields.
  tabs:
  - title: Shell
    type: terminal
    hostname: rhel
  difficulty: basic
  timelimit: 600
- slug: 02-interacting-with-different-users
  id: eqlj1dxwvlwq
  type: challenge
  title: Interacting with a file from different user accounts
  teaser: Working with user permissions
  notes:
  - type: text
    contents: 'In this step, you will be executing the `status.sh` script as two different
      user accounts: __root__, which owns the file, and __guest__, who falls into
      the _other users_ permissions category. This script prints the user who executed
      it, so you will be able to clearly see whether or not a specific user can execute
      the script.'
  assignment: |-
    Recall from the previous step that __status.sh__ has the following permissions:

    <pre class=file>
    -rwxr-x---
    </pre>

    Therefore, __root__ has permission to execute this script.

    ```
    ./status.sh
    ```

    <pre class=file>
    status.sh successfully executed by root
    </pre>

    Focus now on line 2, the line for __status.sh__. The first three letters of the access mode show that the owner of the file has full permissions, __rwx__, so the owner can read, write, and execute this file. Users in the group that owns this file have __r-x__, so they can read and execute but cannot write to this file. Finally, all other users have no permissions, __---__, so they are unable to read, write, or execute this file.

    To see this in action, switch users to the __guest__ account using the `su` command:

    ```
    su - guest
    ```

    Confirm that this command has succeeded by looking at your bash prompt, the user should be __guest__.

    <pre class=file>
    [guest@rhel ~]$
    </pre>

    Navigate back to the directory containing the __status.sh__ script so that you can run it as this new user.

    ```
    cd /srv
    ```

    Try executing the status script as __guest__. Since the guest account is not the user owner of the file and is not part of any owner groups, you are unable to execute this script from this user account.

    ```
    ./status.sh
    ```

    <pre class=file>
    bash: ./status.sh: Permission denied
    </pre>

    Now that you know how files behave differently when operated on by different user accounts, the next steps will show you how to customize permissions to control this behavior.
  tabs:
  - title: Shell
    type: terminal
    hostname: rhel
  difficulty: basic
  timelimit: 600
- slug: 03-modifying-permissions
  id: 6batiimvpiyd
  type: challenge
  title: Changing permissions (symbolic)
  teaser: Using the `chmod` command with symbolic paths
  notes:
  - type: text
    contents: |-
      The `chmod` command is how you modify the permissions associated with files and directories. The `chmod` command has two different ways to modify permissions: symbolic and absolute. Symbolic permissions have the same format as the access mode output of `ls -l`.  In this mode, you use the characters `r`, `w`, and `x` to set the read, write, and execute permissions. The other mode, absolute, instead uses a series of three numbers to correspond to the permissions for the owner, group, and others. These numbers are identical in meaning to the symbolic mode breakdown, they are just more compact and therefore quicker to type. Here is an example of how the two modes relate from Boolean World:

      ![Absolute vs Symbolic permissions](https://github.com/rhel-labs/learn-katacoda/raw/master/instruqt/file-permissions/assets/absVsSym.png)

      Image credit: Boolean World, ["An Introduction to Linux File Permissions"](https://www.booleanworld.com/introduction-linux-file-permissions/)

      >_NOTE:_ This image refers to absolute mode as numeric mode. These two terms are interchangeable and you will commonly see both.

      The crucial takeaway is that each character in a symbolic permission can be converted to a binary number, 1 if the user has that permission and 0 if the user does not. These three binary numbers become a single octal digit, and three such octal digits compose an absolute representation of the file's permissions.

      The upcoming sections walk through a examples of changing permissions using each of these two modes.
  assignment: |-
    In this step, you will be modifying the permissions on the `status.sh` script using symbolic syntax with the `chmod` command. In the previous step, you were unable to execute __status.sh__ as __rhel__. To change that, use the `chmod` command. The plus (`+`) operator will add any permissions that you specify, but it will not change any permissions that you do not explicitly set in the command. So in this case, it will give others read and execute access, but will not change the value of write access for the group. Return to the root terminal to execute this command.

    ```
    chmod o+rx status.sh
    ```

    Verify that this command succeeded using `ls -l`, specifying that you want to only look at __status.sh__.

    ```
    ls -l status.sh
    ```

    <pre class=file>
    -rwxr-xr-x. 1 root root  66 Jun  2 22:42 status.sh
    </pre>

    >_NOTE:_ Just as `o+rx` added read and execute permissions for others, `chmod` accepts the `-` argument to take away permissions. For example, `o-w` would remove write privileges from others while leaving the read and execute values untouched. The `=` argument can be used to explicitly set all permissions symbolically.

    Now the __rhel__ user will be able to read and execute __status.sh__. Switch back to the rhel terminal and re-run the status script:

    ```
    cat /srv/status.sh
    ```

    <pre class=file>
    status.sh successfully executed by guest
    </pre>

    Since you added read and execute permissions, you can do more than just execute this file as __guest__. Use the `cat` command to verify that you can read this file as __guest__.

    ```
    cat /srv/status.sh
    ```

    <pre class=file>
    #!/bin/bash
    echo -n "status.sh successfully executed by "
    whoami
    </pre>

    Symbolic mode is the more expanded permissions format which can appeal to newer users. However, the absolute mode described in the next step can save on keystrokes if you take the time to familiarize yourself with it.
  tabs:
  - title: Shell
    type: terminal
    hostname: rhel
  difficulty: basic
  timelimit: 600
- slug: 04-modifying-aboslute
  id: buys41zo6wcp
  type: challenge
  title: Changing permissions (absolute)
  teaser: Using `chmod` with an absolute path
  notes:
  - type: text
    contents: |-
      Now your next goal is to modify the permissions on __status.sh__ to keep full access for the owner and group members, but prevent anyone else from writing to or executing the file. You can do this with three numbers if you use the absolute syntax.

      The number you would use to do this with `chmod` is __774__. The image below explains how the absolute permission of __774__ relates to the access mode string that is output by `ls -l`.

      ![Absolute permission breakdown](https://github.com/rhel-labs/learn-katacoda/raw/master/instruqt/file-permissions/assets/absBreakdown.png)
  assignment: |-
    The owner user and owner group will have full permissions, but others will only be able to read the file. Return to the first terminal where you are logged in as __root__. Use `chmod` to modify the permissions on __status.sh__ as discussed above:

    ```chmod 774 status.sh
    ```

    Confirm that this change has succeeded by checking the access mode for __status.sh__

    ```
    ls -l status.sh
    ```

    <pre class=file>
    -rwxrwxr--. 1 root root  66 Jun  2 22:42 status.sh
    </pre>

    Now, from the guest terminal, verify that you do not have permission to execute the status script as __guest__:

    ```
    ./status.sh
    ```

    <pre class=file>
    bash: ./status.sh: Permission denied
    </pre>

    However, if you try to read this file, you will see you do have read access as __guest__:

    ```
    cat status.sh
    ```

    <pre class=file>
    #!/bin/bash
    echo -n "status.sh successfully executed by "
    whoami
    </pre>

    >_NOTE:_ You can use `vi` or any other write command to verify that you do not have write access as __guest__ if you wish to verify this as well.

    Many users default to absolute permissions because of how much quicker they are to type. If you are still unsure exactly what these commands are doing, please check out the “How do I manage permissions?” section of [this Enable Sysadmin article](https://www.redhat.com/sysadmin/manage-permissions) to learn more.

    The next step will walk you through changing which user owns a file.
  tabs:
  - title: Shell
    type: terminal
    hostname: rhel
  difficulty: basic
  timelimit: 600
- slug: 05-changing-ownership
  id: nns3sgpndgdz
  type: challenge
  title: Changing file ownership
  teaser: Using the `chown` command
  notes:
  - type: text
    contents: Sometimes it is useful to change who owns a file so that permissions
      can align with the purpose of the file. The `chown` command can do this very
      easily. Just specify the new owner and the file you would like to change.
  assignment: |-
    From the root terminal, confirm that __root__ is the initial owner of the file __tasks.txt__:

    ```
    ls -l tasks.txt
    ```

    <pre class=file>
    -rwxr-x---. 1 root root 117 Jun  2 23:01 tasks.txt
    </pre>

    The third and fourth column of this output are the user and group that own the file. Right now, __root__ is the owner in both cases. Switch to the guest terminal and attempt to read the file:

    ```
    cat tasks.txt
    ```

    <pre class=file>
    cat: tasks.txt: Permission denied
    </pre>

    This read operation is denied, as __guest__ does not have read permission. Returning to the root terminal, change the user that owns __tasks.txt__ to __guest__:

    ```
    chown guest tasks.txt
    ```

    Repeating the search shows that the owner (column 3) has been updated:

    ```
    ls -l tasks.txt
    ```

    <pre class=file>
    -rwxr-x---. 1 guest root 117 Jun  2 23:01 tasks.txt
    </pre>

    Now that __guest__ owns the file instead of __root__, this user has permission to read the file without reconfiguring the access modes.

    ```
    cat tasks.txt
    ```

    <pre class=file>
    1. Finish this Permissions Lab
    2. Do the Networking Configuration Basics Lab
    3. Listen to the latest episode of RHEL Presents
    </pre>

    The fourth column of the `ls -l` output is the group which owns the file. The next step will walk you through changing group ownership.
  tabs:
  - title: Shell
    type: terminal
    hostname: rhel
  difficulty: basic
  timelimit: 600
- slug: 06-changing-group-ownership
  id: hmwnvyeqkynq
  type: challenge
  title: Changing Group Ownership
  teaser: Using the `chgrp` command
  notes:
  - type: text
    contents: Changing group ownership can be much more efficient than manually assigning
      owners, when there are many users that should have the same access to a file.
  assignment: |-
    Group ownership can be changed with the `chgrp` command by adding a colon before the name of the group. Return to the root terminal to execute this command:

    ```
    chown :team tasks.txt
    ```

    Verify the change using `ls -l`:

    ```
    ls -l tasks.txt
    ```

    <pre class=file>
    -rwxr-x---. 1 rhel team 117 Jun  2 23:01 tasks.txt
    </pre>

    This change is reflected in the fourth column of the `ls -l` output, which now says __team__ instead of __root__.

    >_NOTE:_ Some people prefer the `chgrp` command for changing groups as it has identical syntax to `chown`, you do not have to add a colon when using `chgrp`. Others prefer to use `chown` with the colon as above so that they do not have to remember two different commands.

    The final step in this lab will walk you through using `find` to locate any files that may have their permissions configured incorrectly.
  tabs:
  - title: Shell
    type: terminal
    hostname: rhel
  difficulty: basic
  timelimit: 600
- slug: 07-find-audit-permissions
  id: 7qn94deb2lnn
  type: challenge
  title: Auditing permissions
  teaser: Using `find` to audit permissions
  notes:
  - type: text
    contents: The `find` command is highly versatile, but in this case you will be
      using it to locate files that have permissions that may pose security risks.
  assignment: |-
    The `-perm` option causes the `find` command to look at the access modes for each file. In this case you are calling `find` without a path, which means it will start looking in the current directory. First, check for files that have the permission level __755__.

    ```
    find -perm 755
    ```

    This returns only a hidden OS file:

    <pre class=file>
    .
    </pre>

    >_NOTE:_ Recall from the previous step that __755__ corresponds to read, write, and execute access for the owner, and read and execute access for everyone else.

    Consider a situation where you have determined that any permissions above a certain level could pose a security issue. Adding a dash before the permission tells the `find` command to return anything with a permission greater than or equal to the one you are searching for.

    ```
    find -perm -755
    ```

    <pre class=file>
    .
    ./proprietary/contract01.txt
    ./proprietary/contract02.txt
    ./proprietary/contract03.txt
    ./proprietary/contract04.txt
    </pre>

    Notice that this returns many more files. You may not have seen these files from the output of `ls -l`, but `find` searches recursively so it can find files that otherwise may slip through the cracks. The contract files in the  __proprietary__ directory should not be readable by everyone. Furthermore, since these are text files, they should not be executable.

    Running the `chmod` command with a level of __600__ ensures that these files are readable and writable by the owner, but others cannot access them. Instead of running `chmod` individually on each file, you can use the `find` command to execute this permission change on any file that exceeds a certain permission level. The `-type f` option only targets files, so the directory permissions will remain unchanged. The `{} \;` at the end of the command is telling `find` to execute the `chmod` command separately on each file that matches the search criteria.

    ```
    find -perm -755 -type f -exec chmod 600 {} \;
    ```

    To verify that access has been removed, try to read one of the files as the guest account. Switch to the __guest__ terminal and run this command:

    ```
    cat proprietary/contract01.txt
    ```

    <pre class=file>
    cat: proprietary/contract01.txt: Permission denied
    </pre>

    >_NOTE:_ You may be tempted to use `chmod` with the recursive option (`-R`) to make this change instead of using `find`. The `chmod -R` command modifies subdirectories  as well as files, however. Since you are removing execute permissions, using `chmod` recursively would lead to a situation where you could not `cd` into any of the subdirectories that you just modified. This would also prevent you from running any recursive operations to fix this issue, and you would have to manually change the permissions on each subdirectory individually.

    It is very important to double check your work when using the `find` to execute `chmod`, as running this command on the wrong directory could lock users out of all of their files.

    This step is based on information from the [Enable Sysadmin article on the topic](https://www.redhat.com/sysadmin/audit-permissions-find). Head there for more information on increasing the specificity of what `find` returns.
  tabs:
  - title: Shell
    type: terminal
    hostname: rhel
  difficulty: basic
  timelimit: 600
checksum: "14626605702510564504"
