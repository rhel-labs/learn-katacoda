slug: helpful-commands
id: yvaatjd0wtut
type: track
title: Helpful Linux Commands [Admin 101]
description: |
  # Overview:

  Faced with a blinking cursor on your command line, Linux can be intimidating to
  new users who do not know where to start. This lab is designed to show you a
  series of must-know commands that will prove useful on all facets of system
  administration, from finding files to checking the status of system resources.

  # Goal:

  Build a toolbox of basic commands useful to every Linux user.

  # Concepts included in this scenario:
  * Viewing file contents with `cat`
  * Viewing the last 10 lines of a file with `tail`
  * Appending command outputs to a file with the `>>` operator
  * Locating files that match certain criteria using `find` and `locate`
  * Using `grep` with other commands to isolate a portion of their output
  * Checking disk space with `df`
  * Viewing and managing processes with `ps` and `top`
  * Using `free` to view information about the system memory usage
icon: https://storage.googleapis.com/instruqt-frontend/img/tracks/default.png
level: beginner
tags:
- rhel
owner: rhel
developers:
- myee@redhat.com
private: false
published: true
challenges:
- slug: step1
  id: 1xjwy5ynwjxl
  type: challenge
  title: Step 1 - Manipulating file contents
  notes:
  - type: text
    contents: |
      # Overview:

      Faced with a blinking cursor on your command line, Linux can be intimidating to
      new users who do not know where to start. This lab is designed to show you a
      series of must-know commands that will prove useful on all facets of system
      administration, from finding files to checking the status of system resources.

      # Goal:

      Build a toolbox of basic commands useful to every Linux user.

      # Concepts included in this scenario:
      * Viewing file contents with `cat`
      * Viewing the last 10 lines of a file with `tail`
      * Appending command outputs to a file with the `>>` operator
      * Locating files that match certain criteria using `find` and `locate`
      * Using `grep` with other commands to isolate a portion of their output
      * Checking disk space with `df`
      * Viewing and managing processes with `ps` and `top`
      * Using `free` to view information about the system memory usage
  assignment: |
    # Manipulating file contents

    The first step towards modifying files is knowing which files exist. Use `ls`
    to take a look at the contents of the current directory:

    ```
    ls
    ````

    <pre class=file>
    root@rhel:~# ls
    quote.txt
    </pre>

    Use the `cat` command to quickly check what is in file `quote.txt`.
    The `cat` command is short for "concatenate", but it is much more versatile
    than that name suggests.

    ```
    cat quote.txt
    ````

    <pre class=file>
    Just thinking about everything I have been through, and how huge it all feels.
    The fact that it is just a small part of something larger
    </pre>

    Now you can complete the quote by redirecting the output of the `echo` command.
    The command below uses the append redirection operator (`>>`) to cause the
    output of the `echo` command to be written to the end of the file _quote.txt_.

    ```
    echo "makes it seem more manageable." >> quote.txt
    ````

    There is no output, so view the file contents once again to see this change reflected:

    ```
    cat quote.txt
    ````

    <pre class=file>
    Just thinking about everything I have been through, and how huge it all feels.
    The fact that it is just a small part of something larger
    makes it seem more manageable.
    </pre>

    The `>>` operator allows you to add to files from the command line and is particularly
    useful in shell scripting. You can also use it when a command has a lengthy output
    and you want to view that output in a text editor.

    >_NOTE:_ You may also encounter the `>` redirection operator. This operator will
    write the output to a file, overwriting the file if it already exists. By contrast,
    the `>>` operator will append the output to the specified file. The input operator
    (`<`) will redirect data as an input to whatever is called before the operator.
    The pipe operator (`|`) is used to send the output of one command to another
    command so that you can carry out an operation on the results of the first command.
  tabs:
  - title: Terminal
    type: terminal
    hostname: rhel
  difficulty: basic
  timelimit: 900
- slug: step2
  id: tl8ecdgcfxrf
  type: challenge
  title: Step 2 - Viewing the end of log files with `tail`
  assignment: |
    # Viewing the end of log files with `tail`

    Some files are large enough that it is not practical to display their contents
    with `cat`. A common example is log files, which are often packed full of
    information.

    Since `tail` only displays the last ten lines of a file, it is particularly
    useful for viewing recent entries in log files. Take a look at the final
    ten lines of the _boot_ log.

    ```
    tail /var/log/boot.log
    ```

    <pre class=file>
    Starting Enable periodic update of entitlement certificates....
    Starting Dynamic System Tuning Daemon...
    Starting Network Manager Wait Online...
    Starting Hostname Service...
    [  OK  ] Started Enable periodic update of entitlement certificates..
    [  OK  ] Started Permit User Sessions.
    Starting Hold until boot process finishes up...
    Starting Terminate Plymouth Boot Screen...
    [  OK  ] Started Command Scheduler.
    [  OK  ] Started OpenSSH server daemon.
    </pre>

    If you wish to then see the entire file, a text viewer like `less` or `view`
    will show the entire file.

    Adding the `-f` option will follow the log file so that you can see new entries.
    Run this command in Terminal 2 to open an updating view of the _messages_ log, which
    will display system information:

    ```
    tail -f /var/log/messages
    ```

    <pre class=file>
    << OUTPUT ABRIDGED >>
    Jul 15 22:37:26 6d5380e16498 NetworkManager[886]: <warn>  [1626403046.8294] device (ens5): Activation: failed for connection 'Wired connection 1'
    Jul 15 22:37:26 6d5380e16498 NetworkManager[886]: <info>  [1626403046.8298] device (ens5): state change: failed -> disconnected (reason 'none', sys-iface-state: 'managed')
    Jul 15 22:37:26 6d5380e16498 NetworkManager[886]: <info>  [1626403046.8343] dhcp4 (ens5): canceled DHCP transaction
    Jul 15 22:37:26 6d5380e16498 NetworkManager[886]: <info>  [1626403046.8343] dhcp4 (ens5): state changed timeout -> done
    </pre>

    Enter Ctrl-c to break out of this stream.

    <pre>
    Dec  8 18:37:15 rhel systemd[1]: Started man-db-cache-update.service.
    Dec  8 18:37:15 rhel systemd[1]: run-rcd7035fb3d1d4176bf081e5732f65f65.service: Succeeded.
    ^C
    </pre>

    The `logger` utility will write to this _messages_ log. From the original terminal,
    write to this log:

    ```
    logger Hello World
    ```

    Check that this message was recorded.
    ```
    tail /var/log/messages
    ```

    <pre class=file>
    Jul 15 22:39:06 6d5380e16498 dnf[3679]: Metadata cache created.
    Jul 15 22:39:06 6d5380e16498 systemd[1]: dnf-makecache.service: Succeeded.
    Jul 15 22:39:06 6d5380e16498 systemd[1]: Started dnf makecache.
    Jul 15 22:42:07 6d5380e16498 root[3693]: Hello World
    </pre>

    The message you just sent with `logger` is present in _messages_.
  tabs:
  - title: Terminal
    type: terminal
    hostname: rhel
  difficulty: basic
  timelimit: 900
- slug: step3
  id: 7ocr9ixxw0hy
  type: challenge
  title: Step 3 - Locating files
  assignment: |
    # Locating files

    Manipulating files is only useful if you can locate the file you need. This step
    will walk you through two commands that are useful for this, `locate` and `find`.

    The `find` command is great for searching for files which
    satisfy some specified criteria. This step will show an example using the filename,
    but you can also use it to look for files with certain permissions, empty files,
    or much more.

    ```
    find / -name messages
    ```

    <pre class=file>
    /var/log/messages
    </pre>

    The output is the full path to the file. If there are multiple matches, then
    this output would have multiple lines and it would be up to the user
    to decide which is the appropriate file. Instead of having to search through
    countless directories, you can quickly locate the file.

    >_Note:_ An in-depth explanation of using `find` to sort by file permissions
    is included in the [File Permissions Basics lab](https://lab.redhat.com/file-permissions).

    `find` can be input/output intensive, which can sap system resources, especially
    if you run a search that will scan a large amount of candidate files. In fact,
    the search above is exactly that kind of search, since it is looking for filenames
    starting from the root directory. It will check every
    single file on the entire system to see if it is a match.
    The `locate` command instead queries a database to avoid being too I/O intensive.

    ```
    locate messages
    ```

    <pre class=file>
    << OUTPUT ABRIDGED >>
    /usr/share/vim/vim80/syntax/messages.vim
    /usr/share/vim/vim80/syntax/msmessages.vim
    /var/log/messages
    </pre>

    This command finds a variety of files containing _messages_ in their name,
    including the log file that you are looking for, `/var/log/messages`.
    The database that `locate` uses to optimize the search process
    is updated once per day by default, so that means if you are trying to
    locate a newly created file it will not be present in the database.

    Create a new file with `touch`:

    ```
    touch newFile
    ```

    Try to find this newly created file using `locate`:

    ```
    locate newFile
    ```

    There will be no output, as _newFile_ is not in the `locate` database.
    Update the `locate` database using the `updatedb` command:

    ```
    updatedb
    ```

    Re-run the `locate` command to look through the newly updated database:

    ```
    locate newFile
    ```

    <pre class=file>
    /root/newFile
    </pre>

    Now the file is present. This is important to keep in mind so that you do not
    run into the frustrating situation where `locate` failed to find a file that
    existed all along.
  tabs:
  - title: Terminal
    type: terminal
    hostname: rhel
  difficulty: basic
  timelimit: 900
- slug: step4
  id: uci42wsmhdyx
  type: challenge
  title: Step 4 - Searching for text within files and outputs
  assignment: |
    # Searching for text within files and outputs

    `find` is great if you are looking for criteria about a file, but if you instead
    want to locate specific file contents, the `grep` command is what you need.
    To illustrate this, search for the words you added to the _messages_ log file.
    The command below uses the `-r` option to search recursively from the
    starting directory (_/var/log_). This will return all locations in any file
    residing in a subdirectory of _/var/log_ that contain the string "Hello World".

    ```
    grep -r "Hello World" /var/log
    ```

    <pre class=file>
    /var/log/messages:Jul 16 21:38:22 be3f7e9f7264 root[24468]: Hello World
    </pre>

    The output shows the line you added using `logger` earlier in this lab. If you
    do not specify a search location in the `grep` command, it will default to
    your current directory. Additionally, the string being searched for is case-sensitive
    by default. If you want a case-insensitive search, add the `-i` option.

    ```
    grep -ir "hello world" /var/log
    ```

    <pre class=file>
    /var/log/messages:Jul 16 21:38:22 be3f7e9f7264 root[24468]: Hello World
    </pre>

    This option can save you from believing that a string does not exist if you
    weren't sure about how it was capitalized in the file.

    Sometimes you may want to see a few more lines before or after the result of your
    search. This is done using the context option (`-C`). This option allows you
    to specify a number of lines before and after the result of the search to
    display.

    ```
    grep -C1 fact quote.txt
    ```

    <pre class=file>
    Just thinking about everything I have been through, and how huge it all feels.
    The fact that it is just a small part of something larger
    makes it seem more manageable.
    </pre>

    >_NOTE:_ If you wish to only display lines after the result, use `-A` (context
    __a__fter). For lines before the result, use `-B` (context __b__efore).

    Another way to leverage `grep` is by piping the output of another command
    into `grep` using the `|` operator. This saves you effort if you are just looking
    for a specific word or phrase in a lengthy output. You will get a chance to
    try this out in step 6 of this lab.
  tabs:
  - title: Terminal
    type: terminal
    hostname: rhel
  difficulty: basic
  timelimit: 900
- slug: step5
  id: goc1zokr4nrl
  type: challenge
  title: Step 5 - Using `df` to check disk usage
  assignment: |
    # Using `df` to check disk usage

    A large part of a system administrator's job is to be able to diagnose what
    is causing a system to misbehave. Disk space being full can lead to unexpected
    behavior, so the `df` command is great to include in any troubleshooting session.

    The `df` command, short for "disk free", shows a breakdown of disk usage.
    The `-h` option will present the sizes in a human readable format:

    ```
    df -h
    ```

    <pre class=file>
    Filesystem             Size  Used Avail Use% Mounted on
    devtmpfs               890M     0  890M   0% /dev
    tmpfs                  909M     0  909M   0% /dev/shm
    tmpfs                  909M  8.5M  901M   1% /run
    tmpfs                  909M     0  909M   0% /sys/fs/cgroup
    /dev/mapper/rhel-root   35G  4.5G   30G  14% /
    /dev/vda1             1014M  197M  818M  20% /boot
    tmpfs                  182M     0  182M   0% /run/user/0
    </pre>

    The usage percentage (_Use%_) column is a great place to start. If any filesystem
    is close to capacity, then it may be unable to perform installations or other
    operations that require data to be written. However, the absolute size of
    the partition will determine what "close to capacity" means. In the case of this
    system, the root partition is 35 GiB. Therefore, even if it is at 80% usage,
    the filesystem will still have 7 GiB to work with. Probably something you
    need to address eventually, but unless you are doing some storage-intensive
    operation that is failing, likely not the cause of immediate issues.

    The _boot_ partition is on the other end of the spectrum, with a size of
    only 1014 MiB. Therefore, if this filesystem is at 80% usage, there will only
    be 200 MiB available. That may not be enough for basic operations such as installing
    system updates. Therefore, it is very concerning if you run `df` and discover
    one of the smaller filesystems is at 80% usage.

    >_NOTE:_ The _tmpfs_ entries are filesystems accessible by the machine that are stored
    in RAM. This means that you don't have to care as much about these filesystems
    when troubleshooting using `df`. A reboot will give you a fresh copy of these
    filesystems.
  tabs:
  - title: Terminal
    type: terminal
    hostname: rhel
  difficulty: basic
  timelimit: 900
- slug: step6
  id: qqlaia9v6cws
  type: challenge
  title: Step 6 - Viewing processes
  assignment: |
    # Viewing processes

    Just as files organize how data is stored on Linux, processes organize all of the
    programs that are running on the system. The `ps` command (short for Process
    Status) will display information about the processes running in the current shell.
    To see all of the processes running on the system and present them in a
    user-readable format, it is common to add the `aux` options to `ps`.

    ```
    ps aux
    ```

    <pre class=file>
    root           1  0.0  0.7 186400 14448 ?        Ss   15:38   0:11 /usr/lib/systemd/systemd --switched-root --system --deserialize 17
    root           2  0.0  0.0      0     0 ?        S    15:38   0:00 [kthreadd]
    root           3  0.0  0.0      0     0 ?        I<   15:38   0:00 [rcu_gp]
    root           4  0.0  0.0      0     0 ?        I<   15:38   0:00 [rcu_par_gp]
    root           6  0.0  0.0      0     0 ?        I<   15:38   0:00 [kworker/0:0H-events_highpri]
    root           9  0.0  0.0      0     0 ?        I<   15:38   0:00 [mm_percpu_wq]
    root          10  0.0  0.0      0     0 ?        S    15:38   0:00 [ksoftirqd/0]
    root          11  0.0  0.0      0     0 ?        I    15:38   0:00 [rcu_sched]

    << OUTPUT ABRIDGED >>
    </pre>

    >_NOTE:_ There is another lab which goes into depth about `ps` and process
    management. For more info on using `ps` (including how to end processes), check
    out the [Service Administration Basics lab](https://lab.redhat.com/service-admin)

    The output of this command is often very lengthy, so this is a great chance
    to apply what you just learned a few steps ago. Using the pipe operator (`|`),
    pipe the output of `ps aux` into the `grep` command to search for a specific
    process. Search for the `tail -f` process that you started in step 2:

    ```
    ps aux | grep tail
    ```

    <pre class=file>
    root       10046  0.0  0.0   7344   928 pts/1    S+   19:26   0:00 tail -f /var/log/messages
    root       10051  0.0  0.0  12136  1136 pts/0    S+   19:26   0:00 grep --color=auto tail
    </pre>

    Here the search finds the `tail -f` process, but the second line of this output
    shows that the search also finds itself.

    `ps` is great for showing a snapshot of the active processes and their
    resource usage, but sometimes it is more useful to have a utility that keeps
    updating this information in real time. `top` does just that.

    ```
    top
    ```

    <pre class=file>
    top - 21:11:07 up  4:10,  2 users,  load average: 0.45, 0.16, 0.06
    Tasks: 114 total,   1 running, 113 sleeping,   0 stopped,   0 zombie
    %Cpu(s):  0.0 us,  0.3 sy,  0.0 ni, 99.3 id,  0.2 wa,  0.2 hi,  0.0 si,  0.0 st
    MiB Mem :   1817.0 total,   1135.0 free,    181.5 used,    500.5 buff/cache
    MiB Swap:   4000.0 total,   4000.0 free,      0.0 used.   1482.2 avail Mem

      PID USER    PR  NI   VIRT   RES   SHR S %CPU %MEM    TIME+ COMMAND
     2940 root    20  0       0     0     0 I  0.3  0.0  0:00.01 kworker/u4:2-flush-253:0
    15893 root    20  0   65416  4736  3952 R  0.3  0.3  0:00.04 top
        1 root    20  0  187008  4968  9800 S  0.0  0.8  0:03.06 systemd
        2 root    20  0       0     0     0 S  0.0  0.0  0:00.01 kthreadd
        3 root     0 -20      0     0     0 I  0.0  0.0  0:00.00 rcu_gp
    </pre>

    In addition to the process info, `top` includes some status information:
    * The system uptime
    * Total number of user accounts
    * 1 minute, 5 minute, and 15 minute load averages
    * The total number of tasks and a breakdown of their status counts
    * The kinds of tasks using the CPU
    * A breakdown of memory and swap usage

    >_NOTE:_ For more information on the `top` preamble, visit section 2 of the [top man page](https://man7.org/linux/man-pages/man1/top.1.html).

    This output will continue updating until you quit `top`. To quit `top` press `q`.
  tabs:
  - title: Terminal
    type: terminal
    hostname: rhel
  difficulty: basic
  timelimit: 900
- slug: step7
  id: hr6t5zml6wx3
  type: challenge
  title: Step 7 - Using `free` to view information about the system memory usage
  assignment: |
    # Using `free` to view information about the system memory usage

    Processes require memory to run, so when the system is running low on free
    memory it can slow down significantly. The `free` command is useful for quickly
    getting a summary of memory usage.

    ```
    free -h
    ```

    The `-h` option outputs the information in a human-readable format.

    <pre class=file>
               total       used      free    shared   buff/cache  available
    Mem:       1.8Gi       156Mi     1.2Gi   16Mi     430Mi       1.5Gi
    Swap:      3.9Gi       0B        3.9Gi
    </pre>

    Let's launch `top` again but this time we'll run it in the background by adding a `&`.

    ```
    top &
    ```

    <pre class=file>
    top &
    [1] 3567
    </pre>

    If the available memory is very low, the fourth column of `ps au` can be
    used for finding which processes are the culprits. To sort the output by
    memory usage, add the `--sort=-%mem` option:

    ```
    ps au --sort=-%mem
    ```

    <pre class=file>
    ps -au --sort=-%mem
    USER         PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND
    root        3566  0.0  0.1  61648  4028 pts/0    R+   19:46   0:00 ps -au --sort=-%mem
    root        2406  0.0  0.1  26112  3816 pts/0    Ss   19:05   0:00 /bin/bash
    root         805  0.0  0.0  16224  2112 ttyS0    Ss+  18:57   0:00 /sbin/agetty -o -p -- \u --keep
    root         804  0.0  0.0  13656  1676 tty1     Ss+  18:57   0:00 /sbin/agetty -o -p -- \u --nocl
    </pre>

    Suppose you no longer needed `top` and wanted to free up the resources being
    used by this process. One option would be to return to terminal that it is
    running in and quit it. However, it is simpler in most cases to use the `kill`
    command. The process ID shown in the `ps` output is how you refer to the process
    when killing it. Kill the `top` process from this terminal:

    ```
    kill -9 $(pidof top)
    ```

    Here's what you should see in the terminal.

    ```
    root@rhel:~# ps -au
    USER         PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND
    root         820  0.0  0.0  13656  1716 tty1     Ss+  18:33   0:00 /sbin/agetty -o -p -- \u --nocl
    root         821  0.0  0.0  16224  2060 ttyS0    Ss+  18:33   0:00 /sbin/agetty -o -p -- \u --keep
    root        2533  0.0  0.1  26112  3760 pts/0    Ss   18:48   0:00 /bin/bash
    root        2696  0.0  0.1  51632  3812 pts/0    T    18:52   0:00 top
    root        2698  0.0  0.1  58728  3944 pts/0    R+   18:53   0:00 ps -au
    root@rhel:~# kill -9 2696
    root@rhel:~# ps -au
    USER         PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND
    root         820  0.0  0.0  13656  1716 tty1     Ss+  18:33   0:00 /sbin/agetty -o -p -- \u --nocl
    root         821  0.0  0.0  16224  2060 ttyS0    Ss+  18:33   0:00 /sbin/agetty -o -p -- \u --keep
    root        2533  0.0  0.1  26112  3760 pts/0    Ss   18:48   0:00 /bin/bash
    root        2699  0.0  0.1  58728  3920 pts/0    R+   18:53   0:00 ps -au
    [1]+  Killed                  top
    ```

    This does not show any output, but you can see that `top` is no longer running.

    If you want more exercises on this topic, more information on process management
    can be found in the [Service Admin Basics lab](https://lab.redhat.com/service-admin).
  tabs:
  - title: Terminal
    type: terminal
    hostname: rhel
  difficulty: basic
  timelimit: 900
checksum: "17136611195180465595"
