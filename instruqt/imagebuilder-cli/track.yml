slug: imagebuilder-cli
id: y8qzfruiyge9
type: track
title: Design and build virtual machine images using commandline tools [Image Builder]
description: |+
  # Goal:
  After completing this scenario, users will be able to create customized Red Hat Enterprise Linux images using the `composer-cli` command.

  # Concepts included in this scenario:
  * Creating a custom blueprint to use for machine image creation
  * Building a custom Red Hat Enterprise Linux machine image
  * Monitoring the image build process
  * Validate the completed machine image

  # Example Usecase:
  Using the Image Builder commandline interface to make system images would be a
  consistent, repeatable, automatable way to build the same machine images, but
  output the image to different cloud formats for use in a hybrid cloud
  environment.

icon: https://storage.googleapis.com/instruqt-frontend/img/tracks/default.png
level: beginner
tags:
- rhel
owner: rhel
developers:
- ehendric@redhat.com
private: false
published: true
skipping_enabled: true
challenges:
- slug: step1
  id: dfnx1jnxvbhy
  type: challenge
  title: Step 1
  notes:
  - type: text
    contents: |+
      # Goal:
      After completing this scenario, users will be able to create customized Red Hat Enterprise Linux images using the `composer-cli` command.

      # Concepts included in this scenario:
      * Creating a custom blueprint to use for machine image creation
      * Building a custom Red Hat Enterprise Linux machine image
      * Monitoring the image build process
      * Validate the completed machine image

      # Example Usecase:
      Using the Image Builder commandline interface to make system images would be a
      consistent, repeatable, automatable way to build the same machine images, but
      output the image to different cloud formats for use in a hybrid cloud
      environment.

  assignment: |
    # Install and enable required software

    Before you start building images with image builder, the software required to
    perform the tasks must be installed on the system.  Specifically, the
    `composer-cli` package which provides the `composer-cli` command, and the
    `osbuild-composer` package which provides the back-end service used to produce
    the virtual machine images.

    ```
    yum -y install composer-cli osbuild-composer
    ```

    <pre class='file'>
    <<< OUTPUT ABRIDGED >>>

    ==========================================================================================================================================
     Package                            Arch      Version                                           Repository                           Size
    ==========================================================================================================================================
    Installing:
     composer-cli                  x86_64       28.14.58-1.el8                                    rhel-8-for-x86_64-appstream-rpms        86 k
     osbuild-composer              x86_64       28.4-1.el8                                        rhel-8-for-x86_64-appstream-rpms        19 k
    Installing dependencies:
     bubblewrap                    x86_64       0.4.0-1.el8                                       rhel-8-for-x86_64-baseos-rpms           50 k
     fuse                          x86_64       2.9.7-12.el8                                      rhel-8-for-x86_64-baseos-rpms           83 k

    <<< OUTPUT ABRIDGED >>>

    Complete!
    </pre>

    Now that the software has been successfully installed on the system, you also need to activate the `osbuild-composer` service so that the `composer-cli`
    command can interact with the service that is responsible for queuing and creating the machine images.

    ```
    systemctl enable --now osbuild-composer.socket
    ```

    <pre class='file'>
    Created symlink /etc/systemd/system/multi-user.target.wants/osbuild-composer.socket â†’ /usr/lib/systemd/system/osbuild-composer.socket.
    </pre>

    Now that the service is accessible, you are ready to start working with image builder to create machine images.
  tabs:
  - title: Terminal
    type: terminal
    hostname: rhel
  difficulty: basic
  timelimit: 600
- slug: step2
  id: q5ddpngfpvek
  type: challenge
  title: Step 2
  notes:
  - type: text
    contents: |
      # Create a blueprint from a file

      In this step, you will be creating a new blueprint used to build a machine image and update it to include extra packages.
  assignment: |
    # Create a blueprint from a file

    First, look at what blueprints are available on the system.

    ```
    composer-cli blueprints list
    ```

    This system has no existing blueprints. So, let us go ahead and create a blueprint.

    The `composer-cli` will take as input a TOML formatted file (Tom's Obvious Minimal Language)
    that describes the blueprint used to define our machine image.

    To save  some time look at the __node-app-server.toml__ file that has already been pre-created using a tool
    like `cat` or `less`.

    ```
    cat node-app-server.toml
    ```

    <pre class='file'>
    name = "node-app-server"
    description = "Sample image for the node.js application server"
    version = "0.0.1"
    modules = []
    groups = []
    </pre>

    The name of the blueprint is called __node-app-server__. It is recommended that you also include a description so that
    others using this blueprint know what system image they are building. At this point, the blueprint file does not have
    any packages but we will add the `nodejs` and `nginx` packages to it.

    `nodejs` is distributed as an application stream for Red Hat Enterprise Linux, so you will need to add a __[[packages]]__
    section to the node-app-server.toml file adding `nodejs` to the build.

    ```
    printf '\n[[packages]]\nname = "nodejs"\nversion = "*"' >> node-app-server.toml
    ```

    The `printf` command appends the following formatted stanza to the node-app-server.toml file.

    <pre class='file'>
    [[modules]]
    name = "nodejs"
    version = "*"
    </pre>

    Similarly, add the `nginx` package to the blueprint file.

    ```
    printf '\n[[packages]]\nname = "nginx"\nversion = "*"' >> node-app-server.toml
    ```

    In order to create the blueprint from the local TOML file, we will use the `blueprints push` cli option.

    ```
    composer-cli blueprints push node-app-server.toml
    ```

    To verify that your update has been made, review the log of changes made
    to the node-app-server blueprint.

    ```
    composer-cli blueprints changes node-app-server
    ```

    <pre class='file'>
    node-app-server
        2020-07-13T23:07:57Z  e4284083bad43ded8a4a9ea2947a5f45be72f8c4
        Recipe node-app-server, version 0.0.1 saved.
    </pre>


    >**Note:** in the above command output, your date and time will be different than the date and time that appears in the example output.

    You can also review the contents of the node-app-server blueprint to verify
    that the `nodejs` and `nginx` modules are reflected in the active version of the
    blueprint instructions.

    ```
    composer-cli blueprints show node-app-server
    ```

    <pre class='file'>
    name = "node-app-server"
    description = "Sample image for the node.js application server"
    version = "0.0.1"
    modules = []
    groups = []

    [[packages]]
    name = "nodejs"
    version = "*"

    [[packages]]
    name = "nginx"
    version = "*"
    </pre>

    In the above output, you can see that the `nodejs` and `nginx` packages are now
    included in the node-app-server blueprint definition.
  tabs:
  - title: Terminal
    type: terminal
    hostname: rhel
  difficulty: basic
  timelimit: 600
- slug: step3
  id: zw0bwwqqffxk
  type: challenge
  title: Step 3
  notes:
  - type: text
    contents: |+
      # Building a machine image

      In this step you will build a machine image from the node-app-server blueprint definition you made in the previous step.

  assignment: |
    # Building a machine image

    Use the `composer-cli` command to start a compose based on the
    node-app-server blueprint.  For this lab, you will use the output format
    of __qcow2__. However, you could build any of the following types of images:

    | Output type      |  Details                |
    |------------------|:-----------------------:|
    | ami              |  Amazon EC2             |
    | openstack        |  OpenStack image        |
    | qcow2            |  qcow2 image            |
    | rhel-edge-commit |  RHEL edge image        |
    | tar              |  tar archive            |
    | vhd              |  virtual hard disk      |
    | vmdk             |  Virtual Machine disk   |


    ```
    composer-cli compose start node-app-server qcow2
    ```

    <pre class='file'>
    Compose 00403772-ff12-43d4-b09a-bddf28f20709 added to the queue
    </pre>

    The compose, or build of the image, is tracked using a UUID, in the above
    example output, 00403772-ff12-43d4-b09a-bddf28f20709.  Your UUID should be
    different and unique to your build.

    Composes are queued and completed in the order that they were received.  You
    can look at the status of the queue using `composer-cli compose status`.

    ```
    composer-cli compose status
    ```
    <pre class='file'>
    00403772-ff12-43d4-b09a-bddf28f20709 RUNNING  Tue Feb 16 16:21:08 2021 node-app-server 0.0.1 qcow2
    </pre>

    The status will display all queued (WAITING), running (RUNNING), and
    completed (FINISHED) composes.
  tabs:
  - title: Terminal
    type: terminal
    hostname: rhel
  difficulty: basic
  timelimit: 600
- slug: step4
  id: zparnbi5qrae
  type: challenge
  title: Step 4
  notes:
  - type: text
    contents: |+
      # Inspecting the image

      In this step, you will access the machine image created in a previous step in order to verify that the `nodejs` and `nginx` packages added in earlier steps were added to the resulting machine image.

  assignment: |
    # Inspecting the image

    In the next steps, you will access the machine image, however it will not work
    if the machine image is not yet completed.  The below command is a small
    `until` shell script that will run until the completed machine image is created.

    ```
    until $(composer-cli compose status | head -n1 | grep FINISHED &>/dev/null); do echo "Compose not finished ... waiting 10 seconds"; sleep 10; done; echo "COMPOSE FINISHED"
    ```

    Now that the machine image compose is finished, download the completed machine
    image into your current directory.

    ```
    composer-cli compose image $(composer-cli compose status | head -n1 | cut -f1 -d" ")
    ```

    <pre class="file">
    00403772-ff12-43d4-b09a-bddf28f20709-disk.qcow2: 686.96 MB
    </pre>

    The above command takes the UUID of the compose as an argument.  We embedded
    an additional call to `composer-cli compose status` along with some data
    grooming to put this into the command for you to run.  Alternatively, you could
    have copy/pasted from the output of your status from the previous step.

    Now that the machine image is available locally, mount the disk image into your
    directory tree at the /mnt mountpoint. For this, we will mount the qcow2 image
    as a network block device (NBD).

    Load the NBD kernel module using the `modprobe` utility -

    ```
    modprobe nbd
    ```

    Attach a qcow2 virtual image file that was downloaded into the current directory -

    ```
    qemu-nbd --connect=/dev/nbd0 $(composer-cli compose status | head -n1 | cut -f1 -d" ")-disk.qcow2
    ```

    Find the virtual machine partition so that we can mount it -

    ```
    fdisk /dev/nbd0 -l
    ```

    <pre class="file">
    Disk /dev/nbd0: 10 GiB, 10737418240 bytes, 20971520 sectors
    Units: sectors of 1 * 512 = 512 bytes
    Sector size (logical/physical): 512 bytes / 512 bytes
    I/O size (minimum/optimal): 512 bytes / 512 bytes
    Disklabel type: gpt
    Disk identifier: D209C89E-EA5E-4FBD-B161-B461CCE297E0

    Device       Start      End  Sectors  Size Type
    /dev/nbd0p1   2048     4095     2048    1M BIOS boot
    /dev/nbd0p2   4096   208895   204800  100M EFI System
    /dev/nbd0p3 208896 20971486 20762591  9.9G Linux filesystem
    </pre>

    The partition of the disk is `/dev/nbd0p1`

    Mount the partition to some mountpoint (in this case `/mnt`) -

    ```
    mount /dev/nbd0p3 /mnt
    ```

    Temporarily change the root directory of the bash shell to be the directory holding the contents of
    your machine image.

    ```
    chroot /mnt
    ```

    Now, all the commands run are being executed from within the machine image
    and use the machine image's files and content.  Use an `rpm` query to confirm
    that `nodejs` and `nginx` are included in the machine image.

    ```
    rpm -q nodejs nginx
    ```

    <pre class="file">
    nodejs-10.23.1-1.module+el8.3.0+9502+012d8a97.x86_64
    nginx-1.14.1-9.module+el8.0.0+4108+af250afe.x86_64</pre>

    From the above output, you can verify that both the `nodejs` and `nginx` packages were
    installed into this machine image.

    Now that the verification is complete, you can exit the chroot'ed bash shell.

    ```
    exit
    ```

    Unmount the verified machine disk image from your filesystem.

    ```
    umount /mnt
    ```

    Disconnect the network block device

    ```
    qemu-nbd --disconnect /dev/nbd0
    ```

    <pre class="file">
    /dev/nbd0 disconnected
    </pre>

    Remove the NBD kernel module

    ```
    rmmod nbd
    ```
  tabs:
  - title: Terminal
    type: terminal
    hostname: rhel
  difficulty: basic
  timelimit: 600
- slug: step5
  id: y9zff9ryrbh2
  type: challenge
  title: Step 5
  notes:
  - type: text
    contents: |+
      # Troubleshooting a compose

      Sometimes machine image builds are not successful. Looking at the logs of the build may be useful when troubleshooting.

  assignment: |
    # Troubleshooting a compose

    ```
    composer-cli compose log $(composer-cli compose status | head -n1 | cut -f1 -d" ")
    ```

    Throughout the lab, you have seen the UUID of the compose transaction used in
    command output and as an argument for working with individual machine image
    operations.  The osbuild-composer back-end also uses this UUID to store data about
    this, specific, machine image build.

    To look at the data associated with the machine image build you completed in the lab -

    ```
    composer-cli compose results $(composer-cli compose status | head -n1 | cut -f1 -d" ")
    ```

    The output is a .tar that includes the logs, status, and resulting image.

    To view the contents of the tar file -

    ```
    tar -tvf $(composer-cli compose status | head -n1 | cut -f1 -d" ").tar
    ```
  tabs:
  - title: Terminal
    type: terminal
    hostname: rhel
  difficulty: basic
  timelimit: 600
checksum: "4221931182160644518"
